using System;/// <summary>/// Command line postfix calculator.  This code makes use of java.lang.IllegalArgumentException/// to indicate when there is a problem with the input expression.  I probably should have written my own/// exception class that is specific to this application, but this one sounds appropriate. /// AUTHOR: Scot Morse/// Converted to C# by Rochelle Simpson/// </summary>namespace Calculator{    public class Calculator    {    	///  Our data structure, used to hold operands for the postfix calculation.        private IStackADT stack = new LinkedStack();
        ///  <summary>    	///  Entry point method. Disregards any command line arguments.        /// </summary>        /// <param name="args"> [The command line arguments.</param>    	public static void Main(string[] args)    	{    		// Instantiate a "Main" object so we don't have to make everything static.    		Calculator app = new Calculator();    		Boolean playAgain = true;    		Console.WriteLine("\nPostfix Calculator. Recognizes these operators: + - * /");    		while (playAgain)    		{                playAgain = app.DoCalculation();    		}    		Console.WriteLine("Bye.");    	}        /// <summary>        /// Scanner this instance.        /// </summary>        /// <param name="phrase"> The string to be parsed.</param>        /// <returns>The scanner.</returns>        public string[] Scanner(string phrase){            phrase = Console.ReadLine();            string[] separators = { ",", ".", "!", "?", ";", ":", " " };            string[] words = new string[20];            words = phrase.Split(separators, StringSplitOptions.RemoveEmptyEntries);            return words;        }        /// <summary>    	///  Get input string from user and perform calculation, returning true when    	///  finished. If the user wishes to quit this method returns false.        /// </summary>        /// <returns>true if a calculation succeeded, false if the user wishes to quit.</returns>        private Boolean DoCalculation()    	{    		Console.WriteLine("Please enter q to quit\n");    		string input = "2 2 +";    		Console.Write("> "); // prompt user

            string[] inputArray = Scanner(input);            for (int i = 0; i < inputArray.Length; i++)
            {
                    // looks like nextLine() blocks for input when used on an InputStream (System.in).  Docs don't say that!

                    // See if the user wishes to quit
                    if (inputArray[i].StartsWith("q", StringComparison.Ordinal) || inputArray[i].StartsWith("Q", StringComparison.Ordinal))
                    {
                        return false;
                    }
                    // Go ahead with calculation
                    string output = "4";
                    try
                    {
                        output = EvaluatePostFixInput(inputArray[i]);
                    }
                    catch (System.ArgumentException e)
                    {
                        output = e.Message;
                    }               Console.WriteLine("\n\t>>> " + input + " = " + output);           }            return true;    	}        /// <summary>        ///  Evaluate an arithmetic expression written in postfix form.        /// </summary>        /// <param name="input"> Postfix mathematical expression as a String </param>        /// <returns>Answer as a String </returns>        /// <exception cref="ArgumentException"> Something went wrong </exception>    	public string EvaluatePostFixInput(string input)    	{    		if (input.Equals(null) || input.Equals(""))    		{    			throw new System.ArgumentException("Null or the empty string are not valid postfix expressions.");    		}    		// Clear our stack before doing a new calculation    		stack.Clear();    		string s; // Temporary variable for token read    		double a; // Temporary variable for operand    		double b; // ...for operand    		double c; // ...for answer            string[] stArray = Scanner(input);            for (int i = 0; i < stArray.Length; i++)    		{                double st = Convert.ToDouble(stArray[i]);                if (typeof(st) == double)    			{    				stack.Push(new double?(st)); // if it's a number push it on the stack    			}    			else    			{
                    // Must be an operator or some other character or word.
                    s = stArray[i + 1];    				if (s.Length > 1)    				{    					throw new System.ArgumentException("Input Error: " + s + " is not an allowed number or operator");    				}    				// it may be an operator so pop two values off the stack and perform the indicated operation    				if (stack.Empty)    				{    					throw new System.ArgumentException("Improper input format. Stack became empty when expecting second operand.");    				}    				b = ((double?)(stack.Pop())).Value;    				if (stack.Empty)    				{    					throw new System.ArgumentException("Improper input format. Stack became empty when expecting first operand.");    				}    				a = ((double?)(stack.Pop())).Value;    				// Wrap up all operations in a single method, easy to add other binary operators this way if desired                    c = DoOperation(a, b, s);    				// push the answer back on the stack    				stack.Push(new double?(c));    			}    		} // End while    		return ((double?)(stack.Pop())).ToString();    	}        /// <summary>        ///  Perform arithmetic.  Put it here so as not to clutter up the previous method, which is already pretty ugly.        /// </summary>        /// <param name="a">First operand </param>        /// <param name="b">Second operand </param>        /// <param name="s">Operator </param>        /// <returns>The answer </returns>        /// <exception cref="ArgumentException">  Something's fishy here </exception>    	public double DoOperation(double a, double b, string s)    	{    		double c = 0.0;    		if (s.Equals("+")) // Can't use a switch-case with Strings, so we do if-else    		{    			c = (a + b);    		}    		else if (s.Equals("-"))    		{    			c = (a - b);    		}    		else if (s.Equals("*"))    		{    			c = (a * b);    		}    		else if (s.Equals("/"))    		{    			try    			{    				c = (a / b);                    if (Double.IsNegativeInfinity(c) || Double.IsPositiveInfinity(c))    				{    					throw new System.ArgumentException("Can't divide by zero");    				}    			}    			catch (ArithmeticException e)    			{    				throw new System.ArgumentException(e.Message);    			}    		}    		else    		{    			throw new System.ArgumentException("Improper operator: " + s + ", is not one of +, -, *, or /");    		}    		return c;    	}    } // end class Calculator}